# 1. 定义整个流水线的“工序”顺序
# 这里规定了必须先完成所有 build 阶段的任务，才能开始 deploy 阶段的任务
stages:
  - build
  - deploy

# ----------------------------------------------------------------

# 2. 定义第一个任务，并分配到 build 工序
build_frontend:
  stage: build
  image: node:22
  script:
    - echo "--- Building frontend for hh_branch ---"
    - cd frontend/realtime-monitor-fronted
    - npm config set registry https://registry.npmmirror.com/
    - npm install
    - npm run build
  artifacts:
    paths:
      - frontend/realtime-monitor-fronted/dist/
  rules:
    - if: '$CI_COMMIT_BRANCH == "hh_branch"'

# ----------------------------------------------------------------

# 3. 定义第二个任务，并分配到 deploy 工序
# 您刚才引用的，就是下面这部分代码
deploy_to_server:
  stage: deploy
  image: alpine:latest

  # 在before_script中，我们用ssh-keyscan提前完成主机信任
  before_script:
    - 'apk update && apk add openssh-client sshpass rsync'
    - 'mkdir -p ~/.ssh'
    - 'chmod 700 ~/.ssh'
    # 【关键修改】使用ssh-keyscan获取服务器的公钥并添加到known_hosts文件中
    - 'ssh-keyscan -H $SERVER_HOST >> ~/.ssh/known_hosts'

  # script部分现在可以非常简洁，无需任何额外的SSH选项
  script:
    - echo "--- Starting Deployment (ssh-keyscan method) ---"
    - |
      echo "1. Deploying frontend files..."
      SSHPASS="$SERVER_PASSWORD" rsync -avz --delete frontend/realtime-monitor-fronted/dist/ ${SERVER_USER}@${SERVER_HOST}:/usr/local/nginx/html/
    - |
      echo "2. Updating backend and restarting service..."
      SSHPASS="$SERVER_PASSWORD" ssh ${SERVER_USER}@${SERVER_HOST} "
        echo '--> Pulling latest backend code...';
        cd /root/realtime-video-monitoring-hh/realtime-video-monitoring;
        git checkout hh_branch;
        git pull;
        
        echo '--> Restarting backend service...';
        sudo systemctl restart video-monitoring-backend.service;
        
        echo '--> Deployment finished!';
      "
  rules:
    - if: '$CI_COMMIT_BRANCH == "hh_branch"'